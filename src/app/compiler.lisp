(require "../utils/sourceToSource.lisp")
(require "../utils/label.lisp")

(defun compile-lisp (expr asm )
;;(print expr)
    (cond ((atom expr) (compile-atom expr asm))
          ((listp expr) 
            (cond ((equal (car expr) '+) (compile-add expr asm))
                  ((equal (car expr) '-) (compile-sub expr asm))
                  ((equal (car expr) '*) (compile-mult expr asm))
                  ((equal (car expr) '/) (compile-div expr asm))
                  ((equal (car expr) '=) (compile-equal expr asm))
                  ((equal (car expr) '<) (compile-lower expr asm))
                  ((equal (car expr) '<=) (compile-lower-equal expr asm))
                  ((equal (car expr) '>) (compile-bigger expr asm))
                  ((equal (car expr) '>=) (compile-bigger-equal expr asm))
                  ((equal (car expr) 'and) (compile-and expr asm))
                  ((equal (car expr) 'or) (compile-or expr asm))
                  ((equal (car expr) 'not) (compile-not expr asm))
                  ((equal (car expr) 'defun) 'form1)
                  ((equal (car expr) 'let) 'form1)
                  ((equal (car expr) 'cond) 'form1)
                  ((equal (car expr) 'if) 'form1)
                  ((equal (car expr) 'when) 'form1)
                  ((atom  (car expr)) (append (compile-atom-in-list expr asm) (compile-atom-in-list (cdr expr) asm)));;Compilation d'une liste d'Ã©lem
                  (t 'form1);;evaluation des fct car sinon echec car soit on ne connait pas la fct doit ce n'est pas une fct
            )
         
         )
    )
)

(defun compile-atom-in-list (expr asm)
    (let ((asm-atom  (cons (cons 'MOVE (cons (car expr) (cons :R0 nil) )) (cons '(PUSH :R0) nil))))
        (append asm-atom asm)
    )
)

(defun compile-atom (expr asm)
    (let ((asm-atom  (cons (cons 'MOVE (cons expr (cons :R0 nil) )) (cons '(PUSH :R0) nil))))
        (append asm-atom asm)
    )
)

(defun compile-add (expr asm)
    ;;(print (nToBin expr))
    (let ((expr-s2s (nToBin expr)))
        (let (
            (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            )
            (append (compile-lisp operand1 asm) (compile-lisp operand2 asm)
            '((POP :R1)(POP :R0)(ADD :R0 :R1)(PUSH :R0)) asm
            )
        )
    )
)

(defun compile-sub (expr asm)
    ;;(print (nToBin expr))
    (let ((expr-s2s (nToBin expr)))
        (let (
            (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            )
            (append (compile-lisp operand1 asm) (compile-lisp operand2 asm)
            '((POP :R1)(POP :R0)(SUB :R0 :R1)(PUSH :R0)) asm
            )
        )
    )
)

(defun compile-mult (expr asm)
    ;;(print (nToBin expr))
    (let ((expr-s2s (nToBin expr)))
        (let (
            (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            )
            (append (compile-lisp operand1 asm) (compile-lisp operand2 asm)
            '((POP :R1)(POP :R0)(MULT :R0 :R1)(PUSH :R0)) asm
            )
        )
    )
)

(defun compile-div (expr asm)
    ;;(print (nToBin expr))
    (let ((expr-s2s (nToBin expr)))
        (let (
            (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            )
            (append (compile-lisp operand1 asm) (compile-lisp operand2 asm)
            '((POP :R1)(POP :R0)(DIV :R0 :R1)(PUSH :R0)) asm
            )
        )
    )
)

(defun compile-equal (expr asm)
    (let ((expr-s2s (ntobin expr)))
        (let ( (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            (etiq-fin (new-label))
            (etiq-true (new-label))
        )
        (append (compile-lisp operand1 asm) (compile-lisp operand2 asm) '((POP :R1)(POP :R0)(CMP :R0 :R1))
        `((JEQ ,etiq-true) (MOVE nil :R0)(PUSH :R0)(JMP ,etiq-fin)(LABEL ,etiq-true)(MOVE t :R0)(PUSH :R0)(LABEL ,etiq-fin) )
        )
        )
    )
)

(defun compile-lower (expr asm)
    (let ((expr-s2s (ntobin expr)))
        (let ( (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            (etiq-fin (new-label))
            (etiq-true (new-label))
        )
        (append (compile-lisp operand1 asm) (compile-lisp operand2 asm) '((POP :R1)(POP :R0)(CMP :R0 :R1))
        `((JLT ,etiq-true) (MOVE nil :R0)(PUSH :R0)(JMP ,etiq-fin)(LABEL ,etiq-true)(MOVE t :R0)(PUSH :R0)(LABEL ,etiq-fin) )
        )
        )
    )
)

(defun compile-bigger (expr asm)
    (let ((expr-s2s (ntobin expr)))
        (let ( (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            (etiq-fin (new-label))
            (etiq-true (new-label))
        )
        (append (compile-lisp operand1 asm) (compile-lisp operand2 asm) '((POP :R1)(POP :R0)(CMP :R0 :R1))
        `((JGT ,etiq-true) (MOVE nil :R0)(PUSH :R0)(JMP ,etiq-fin)(LABEL ,etiq-true)(MOVE t :R0)(PUSH :R0)(LABEL ,etiq-fin) )
        )
        )
    )
)


(defun compile-lower-equal (expr asm)
    (let ((expr-s2s (ntobin expr)))
        (let ( (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            (etiq-fin (new-label))
            (etiq-true (new-label))
        )
        (append (compile-lisp operand1 asm) (compile-lisp operand2 asm) '((POP :R1)(POP :R0)(CMP :R0 :R1))
        `((JLE ,etiq-true) (MOVE nil :R0)(PUSH :R0)(JMP ,etiq-fin)(LABEL ,etiq-true)(MOVE t :R0)(PUSH :R0)(LABEL ,etiq-fin) )
        )
        )
    )
)

(defun compile-bigger-equal (expr asm)
    (let ((expr-s2s (ntobin expr)))
        (let ( (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            (etiq-fin (new-label))
            (etiq-true (new-label))
        )
        (append (compile-lisp operand1 asm) (compile-lisp operand2 asm) '((POP :R1)(POP :R0)(CMP :R0 :R1))
        `((JGE ,etiq-true) (MOVE nil :R0)(PUSH :R0)(JMP ,etiq-fin)(LABEL ,etiq-true)(MOVE t :R0)(PUSH :R0)(LABEL ,etiq-fin) )
        )
        )
    )
)

(defun compile-and (expr asm)
        (let ((expr-s2s (ntobin expr)))
        (let ( (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            (etiq-fin (new-label))
            (etiq-false (new-label))
        )
        (append (compile-lisp operand1 asm) (compile-lisp operand2 asm) '((POP :R1)(POP :R0)(CMP nil :R1))
        `((JEQ ,etiq-false)
          (CMP nil :R0) 
          (JEQ ,etiq-false) 
          (MOVE t :R0)
          (PUSH :R0)
          (JMP ,etiq-fin)
          (LABEL ,etiq-false)
          (MOVE nil :R0)
          (PUSH :R0)
          (LABEL ,etiq-fin) )
        )
        )
    )
)

(defun compile-or (expr asm)
        (let ((expr-s2s (ntobin expr)))
        (let ( (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            (etiq-fin (new-label))
            (etiq-true (new-label))
        )
        (append (compile-lisp operand1 asm) (compile-lisp operand2 asm) '((POP :R1)(POP :R0)(CMP t :R1))
        `((JEQ ,etiq-true)
          (CMP t :R0) 
          (JEQ ,etiq-true) 
          (MOVE nil :R0)
          (PUSH :R0)
          (JMP ,etiq-fin)
          (LABEL ,etiq-true)
          (MOVE t :R0)
          (PUSH :R0)
          (LABEL ,etiq-fin))
        )
        )
    )
)

(defun compile-not (expr asm)
        (let ((expr-s2s (ntobin expr)))
        (let ( (operand1 (car(cdr expr-s2s)))
            (etiq-fin (new-label))
            (etiq-true (new-label))
        )
        (append (compile-lisp operand1 asm) '((POP :R0)(CMP t :R0))
        `((JEQ ,etiq-true) 
          (MOVE t :R0)
          (PUSH :R0)
          (JMP ,etiq-fin)
          (LABEL ,etiq-true)
          (MOVE nil :R0)
          (PUSH :R0)
          (LABEL ,etiq-fin))
        )
        )
    )
)

;;(print (compile-lisp '5 '()))
(print (compile-lisp '(not (+ 8 7 (- 5 (* 5 7 8 (/ 2 5))))5) '()))

