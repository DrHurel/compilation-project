(require "../utils/sourceToSource.lisp")
(require "../utils/label.lisp")

(defun compile-lisp (expr asm env )
    (cond ((atom expr) (compile-atom expr asm env ))
          ((listp expr) 
            (cond ((equal (car expr) '+) (compile-add expr asm env ))
                  ((equal (car expr) '-) (compile-sub expr asm env ))
                  ((equal (car expr) '*) (compile-mult expr asm env ))
                  ((equal (car expr) '/) (compile-div expr asm env ))
                  ((equal (car expr) '=) (compile-equal expr asm env ))
                  ((equal (car expr) '<) (compile-lower expr asm env ))
                  ((equal (car expr) '<=) (compile-lower-equal expr asm env ))
                  ((equal (car expr) '>) (compile-bigger expr asm env ))
                  ((equal (car expr) '>=) (compile-bigger-equal expr asm env ))
                  ((equal (car expr) 'and) (compile-and expr asm env ))
                  ((equal (car expr) 'or) (compile-or expr asm env ))
                  ((equal (car expr) 'not) (compile-not expr asm env ))
                  ((equal (car expr) 'defun) (compile-defun (cdr expr) asm env  ))
                  ((equal (car expr) 'let) 'form1)
                  ((equal (car expr) 'cond) (compile-if (cond_SAS (cdr expr)) asm env ))
                  ((equal (car expr) 'if) (compile-if expr asm env ))
                  ((equal (car expr) 'when) (compile-when expr asm env ))
                  ;;((atom  (car expr)) (append (compile-atom-in-list expr asm env) (compile-atom-in-list (cdr expr) asm env)));;Compilation d'une liste d'Ã©lem
                  (t '(form1));;evaluation des fct car sinon echec car soit on ne connait pas la fct doit ce n'est pas une fct
            )
         
         )
    )
)

(defun compile-atom-in-list (expr asm env )
    (let ((asm-atom  (cons (cons 'MOVE (cons (car expr) (cons :R0 nil) )) (cons '(PUSH :R0) nil))))
        (append asm-atom asm)
    )
)

(defun compile-atom (expr asm env )
    (let ((var (assoc expr env)))
        (if ( equal var nil)
            (let ((asm-atom  (cons (cons 'MOVE (cons expr (cons :R0 nil) )) (cons '(PUSH :R0) nil))))
            (append asm-atom asm)
            )
            (let ((asm-atom  `((LOAD (:FP,(cdr var)) :R0)(PUSH :R0))))
            (append asm-atom asm)
            )
        )
    )
)

(defun compile-add (expr asm env )
    ;;(print (nToBin expr))
    (let ((expr-s2s (nToBin expr)))
        (let (
            (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            )
            (append (compile-lisp operand1 asm env ) (compile-lisp operand2 asm env )
            '((POP :R1)(POP :R0)(ADD :R0 :R1)(PUSH :R0)) asm
            )
        )
    )
)

(defun compile-sub (expr asm env )
    ;;(print (nToBin expr))
    (let ((expr-s2s (nToBin expr)))
        (let (
            (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            )
            (append (compile-lisp operand1 asm env ) (compile-lisp operand2 asm env )
            '((POP :R1)(POP :R0)(SUB :R0 :R1)(PUSH :R0)) asm
            )
        )
    )
)

(defun compile-mult (expr asm env )
    ;;(print (nToBin expr))
    (let ((expr-s2s (nToBin expr)))
        (let (
            (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            )
            (append (compile-lisp operand1 asm env ) (compile-lisp operand2 asm env )
            '((POP :R1)(POP :R0)(MULT :R0 :R1)(PUSH :R0)) asm
            )
        )
    )
)

(defun compile-div (expr asm env )
    ;;(print (nToBin expr))
    (let ((expr-s2s (nToBin expr)))
        (let (
            (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            )
            (append (compile-lisp operand1 asm env ) (compile-lisp operand2 asm env )
            '((POP :R1)(POP :R0)(DIV :R0 :R1)(PUSH :R0)) asm
            )
        )
    )
)

(defun compile-equal (expr asm env )
    (let ((expr-s2s (ntobin expr)))
        (let ( (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            (etiq-fin (new-label ))
            (etiq-true (new-label ))
        )
        (append (compile-lisp operand1 asm env ) (compile-lisp operand2 asm env ) '((POP :R1)(POP :R0)(CMP :R0 :R1))
        `((JEQ ,etiq-true) (MOVE nil :R0)(PUSH :R0)(JMP ,etiq-fin)(LABEL ,etiq-true)(MOVE t :R0)(PUSH :R0)(LABEL ,etiq-fin) )
        )
        )
    )
)

(defun compile-lower (expr asm env )
    (let ((expr-s2s (ntobin expr)))
        (let ( (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            (etiq-fin (new-label ))
            (etiq-true (new-label ))
        )
        (append (compile-lisp operand1 asm env ) (compile-lisp operand2 asm env ) '((POP :R1)(POP :R0)(CMP :R0 :R1))
        `((JLT ,etiq-true) (MOVE nil :R0)(PUSH :R0)(JMP ,etiq-fin)(LABEL ,etiq-true)(MOVE t :R0)(PUSH :R0)(LABEL ,etiq-fin) )
        )
        )
    )
)

(defun compile-bigger (expr asm env )
    (let ((expr-s2s (ntobin expr)))
        (let ( (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            (etiq-fin (new-label ))
            (etiq-true (new-label ))
        )
        (append (compile-lisp operand1 asm env ) (compile-lisp operand2 asm env ) '((POP :R1)(POP :R0)(CMP :R0 :R1))
        `((JGT ,etiq-true) (MOVE nil :R0)(PUSH :R0)(JMP ,etiq-fin)(LABEL ,etiq-true)(MOVE t :R0)(PUSH :R0)(LABEL ,etiq-fin) )
        )
        )
    )
)


(defun compile-lower-equal (expr asm env )
    (let ((expr-s2s (ntobin expr)))
        (let ( (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            (etiq-fin (new-label ))
            (etiq-true (new-label ))
        )
        (append (compile-lisp operand1 asm env ) (compile-lisp operand2 asm env ) '((POP :R1)(POP :R0)(CMP :R0 :R1))
        `((JLE ,etiq-true) (MOVE nil :R0)(PUSH :R0)(JMP ,etiq-fin)(LABEL ,etiq-true)(MOVE t :R0)(PUSH :R0)(LABEL ,etiq-fin) )
        )
        )
    )
)

(defun compile-bigger-equal (expr asm env )
    (let ((expr-s2s (ntobin expr)))
        (let ( (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            (etiq-fin (new-label ))
            (etiq-true (new-label ))
        )
        (append (compile-lisp operand1 asm env ) (compile-lisp operand2 asm env ) '((POP :R1)(POP :R0)(CMP :R0 :R1))
        `((JGE ,etiq-true) (MOVE nil :R0)(PUSH :R0)(JMP ,etiq-fin)(LABEL ,etiq-true)(MOVE t :R0)(PUSH :R0)(LABEL ,etiq-fin) )
        )
        )
    )
)

(defun compile-and (expr asm env )
        (let ((expr-s2s (ntobin expr)))
        (let ( (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            (etiq-fin (new-label ))
            (etiq-false (new-label ))
        )
        (append (compile-lisp operand1 asm env ) (compile-lisp operand2 asm env ) '((POP :R1)(POP :R0)(CMP nil :R1))
        `((JEQ ,etiq-false)
          (CMP nil :R0) 
          (JEQ ,etiq-false) 
          (MOVE t :R0)
          (PUSH :R0)
          (JMP ,etiq-fin)
          (LABEL ,etiq-false)
          (MOVE nil :R0)
          (PUSH :R0)
          (LABEL ,etiq-fin) )
        )
        )
    )
)

(defun compile-or (expr asm env )
        (let ((expr-s2s (ntobin expr)))
        (let ( (operand1 (car(cdr expr-s2s)))
            (operand2 (car (cdr(cdr expr-s2s))))
            (etiq-fin (new-label ))
            (etiq-true (new-label ))
        )
        (append (compile-lisp operand1 asm env ) (compile-lisp operand2 asm env ) '((POP :R1)(POP :R0)(CMP t :R1))
        `((JEQ ,etiq-true)
          (CMP t :R0) 
          (JEQ ,etiq-true) 
          (MOVE nil :R0)
          (PUSH :R0)
          (JMP ,etiq-fin)
          (LABEL ,etiq-true)
          (MOVE t :R0)
          (PUSH :R0)
          (LABEL ,etiq-fin))
        )
        )
    )
)

(defun compile-not (expr asm env )
        (let ((expr-s2s (ntobin expr)))
        (let ( (operand1 (car(cdr expr-s2s)))
            (etiq-fin (new-label ))
            (etiq-true (new-label ))
        )
        (append (compile-lisp operand1 asm env ) '((POP :R0)(CMP t :R0))
        `((JEQ ,etiq-true) 
          (MOVE t :R0)
          (PUSH :R0)
          (JMP ,etiq-fin)
          (LABEL ,etiq-true)
          (MOVE nil :R0)
          (PUSH :R0)
          (LABEL ,etiq-fin))
        )
        )
    )
)


(defun compile-if (expr asm env )
    (let (
            (cond (car(cdr expr)))
            (then (car (cdr(cdr expr))))
            (else (car (cdr(cdr (cdr expr)))))
            (etiq-fin (new-label ))
            (etiq-true (new-label ))
            )
            (append (compile-lisp cond asm env ) 
                    `((POP :R0)
                    (CMP t :R0)
                    (JTRUE ,etiq-true))
                    (compile-lisp else asm env )
                    `((JMP ,etiq-fin)(LABEL ,etiq-true))
                    (compile-lisp then asm env )
                    `((LABEL ,etiq-fin))
                    asm
            )
        ))
;;(print (compile-lisp '5 '()))
;;(print (compile-lisp '(+ 8 7 (- 5 (* 5 7 8 (/ 2 5)))) '()))
(defun compile-when (expr asm env )
    (let ((queue (cdr expr)))
        (compile-lisp (cons 'cond (cons queue nil)) asm env ))
)

(defun compile-defun (expr asm env )
    (let (
          (parameter-assoc (compile-parameter (car (cdr expr)) '() '()))
          (label-fun (concatenate 'string "begin-" (write-to-string  (car expr))))
          (label-exit (concatenate 'string "exit-" (write-to-string  (car expr))))
        )
        ;;PUSH FP
        ;;FP + 100
        (append `((JUMP ,label-exit) (LABEL ,label-fun)) (compile-lisp (car(cdr (cdr expr))) asm parameter-assoc ) `((LABEL ,label-exit)) asm)

    )    
)

(defun compile-parameter (expr asm env )
(if (= (length expr) 0)
    nil
    (cons (cons (car expr) (- 0(length expr))) (compile-parameter (cdr expr) asm env ))
    )  
)

;;(print (compile-lisp '(cond(cond1 expr1)
;;                (cond2 expr2)
;;                (cond3 expr3)
;;                (cond4 expr4)
;;                (t expr5)
;;               ) '() '() 0))

;;(print (compile-lisp '(when (= c d) (+ 5 6 8 )) '() '()))

;;(print (compile-parameter '(toto titi tata) '() '()))

;;(print (compile-defun '(fct-a-la-con (x y z) (if (= 5 6)
;;    6
;;    5)) '() '()))

(print (compile-lisp '(defun fct-a-la-con (x y z)
    (if (= x y)
        z
        (+ 1 z))) '() '()) )


